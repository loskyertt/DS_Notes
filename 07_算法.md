# 1.二分查找

二分查找算法中，如果使用闭区间方式（即 `i = 0, j = nums.size() - 1`），若 `target` 不在数组中，循环结束时 `i` 和 `j` 的关系为 $i = j + 1$（即 `i` 在 `j` 的右边）。此时：
- `i` 指向的是**第一个大于等于 `target` 的元素**的位置（如果存在这样的元素，否则 `i` 会等于 `nums.size()`）。
- `j` 指向的是**最后一个小于 `target` 的元素**的位置（如果存在这样的元素，否则 `j` 会等于 `-1`）。

> 这个性质在需要插入 `target` 到有序数组时非常有用（即 `i` 就是插入位置）。

二分查找的闭区间实现通常如下：

```cpp
int binarySearch(const vector<int>& nums, int target) {
    int i = 0, j = nums.size() - 1;  // 闭区间：[i, j]
    while (i <= j) {
        int mid = i + (j - i) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            i = mid + 1;
        } else {
            j = mid - 1;
        }
    }
    return -1; // 未找到
}
```

举例说明：假设数组 `nums = [1, 3, 5, 7]`，查找不同的 `target`。

1. `target = 0`（小于所有元素）：
   - 循环结束时 `i = 0`, `j = -1`。
   - `i` 指向第一个大于等于 0 的元素（即 1）的位置（索引 0）。

2. `target = 2`（介于 1 和 3 之间）：
   - 循环结束时 `i = 1`, `j = 0`。
   - `i` 指向第一个大于等于 2 的元素（即 3）的位置（索引 1）。

3. `target = 4`（介于 3 和 5 之间）：
   - 循环结束时 `i = 2`, `j = 1`。
   - `i` 指向第一个大于等于 4 的元素（即 5）的位置（索引 2）。

4. `target = 8`（大于所有元素）：
   - 循环结束时 `i = 4`, `j = 3`。
   - `i` 指向 `nums.size()`（即 4），因为不存在大于等于 8 的元素。

---

# 2.快慢指针

## 2.1 查找链表中点

示例：

```cpp
ListNode *find_middle(ListNode* head){
    ListNode *slow = head, *fast = head;
	
    while(fast && fast->next){
        fast = fast->next->next;
        slow = slow-next
    }

    return slow;
}
```

如这段代码所示，设置快慢指针，让 `fast` 节点走的步数是 `slow` 节点走的步数的两倍。

循环结束后，`slow` 的指向：
- 节点数为奇数：`slow` 正好指向链表中点。
- 节点数为偶数：`slow` 指向后半部分的第一个节点。

这里的 `fast && fast->next` 这是标准的快慢指针写法，适用于链表长度为 **偶数或奇数** 的情况（比如：若 `fast` 能到链表最后一个节点，那么执行`fast->next->next` 就会报错，因为 `fast->next` 此时就是 `nullptr`）。

> 快慢指针除了应用与找链表的中间节点，还可以求解”获取倒数第 `k` 个节点这种问题“，思考一下怎么通过快慢指针求解。

## 2.2 删除数组中元素

下面介绍一种经典的**双指针技巧**，是一种高效的原址删除算法。

```cpp
void remove_target(vector<int> &nums, int target){
	int i = 0;
	
	for(int j = 0; j < nums.size(); ++j){
		if(nums[j] != target){
			nums[i] = nums[j];
			++i;
		}
	}
	
	nums.resize(i);
}
```

**双指针角色：**

- **`i` 指针（慢指针）**：指向下一个应该存放**保留元素**的位置，循环结束后，**`i` 的值 = 有效元素个数 = 新数组长度**。
    
- **`j` 指针（快指针）**：遍历整个数组，检查每个元素。

当 `nums[j] == target` 时（第一次），`i` 指针就会指向 `target` 元素的位置，下次循环的时候会用下一个值 `nums[j]` 覆盖掉 `nums[i]`，再次循环的时候，会把数组中的元素往前移（因为 `i` 落后与 `j`）。

可视化实例，删除数组中的元素 `3`：

```
步骤   i   j  nums[j]  操作          数组状态
初始   0   0    3      跳过        [3,5,3,2,9,10,3,4]
1      0   1    5      复制→i=0    [5,5,3,2,9,10,3,4] → i=1
2      1   2    3      跳过        [5,5,3,2,9,10,3,4]
3      1   3    2      复制→i=1    [5,2,3,2,9,10,3,4] → i=2  
4      2   4    9      复制→i=2    [5,2,9,2,9,10,3,4] → i=3
5      3   5    10     复制→i=3    [5,2,9,10,9,10,3,4] → i=4
6      4   6    3      跳过        [5,2,9,10,9,10,3,4]
7      4   7    4      复制→i=4    [5,2,9,10,4,10,3,4] → i=5

最终：i = 5（有效元素个数）
```

