# 1.二分查找

二分查找算法中，如果使用闭区间方式（即 `i = 0, j = nums.size() - 1`），若 `target` 不在数组中，循环结束时 `i` 和 `j` 的关系为 $i = j + 1$（即 `i` 在 `j` 的右边）。此时：
- `i` 指向的是**第一个大于等于 `target` 的元素**的位置（如果存在这样的元素，否则 `i` 会等于 `nums.size()`）。
- `j` 指向的是**最后一个小于 `target` 的元素**的位置（如果存在这样的元素，否则 `j` 会等于 `-1`）。

> 这个性质在需要插入 `target` 到有序数组时非常有用（即 `i` 就是插入位置）。

二分查找的闭区间实现通常如下：

```cpp
int binarySearch(const std::vector<int>& nums, int target) {
    int i = 0, j = nums.size() - 1;  // 闭区间：[i, j]
    while (i <= j) {
        int mid = i + (j - i) / 2;   // 用 (i+j)/2 可能导致溢出
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            i = mid + 1;
        } else {
            j = mid - 1;
        }
    }
    return -1; // 未找到
}
```

举例说明：假设数组 `nums = [1, 3, 5, 7]`，查找不同的 `target`。

1. `target = 0`（小于所有元素）：
   - 循环结束时 `i = 0`, `j = -1`。
   - `i` 指向第一个大于等于 0 的元素（即 1）的位置（索引 0）。

2. `target = 2`（介于 1 和 3 之间）：
   - 循环结束时 `i = 1`, `j = 0`。
   - `i` 指向第一个大于等于 2 的元素（即 3）的位置（索引 1）。

3. `target = 4`（介于 3 和 5 之间）：
   - 循环结束时 `i = 2`, `j = 1`。
   - `i` 指向第一个大于等于 4 的元素（即 5）的位置（索引 2）。

4. `target = 8`（大于所有元素）：
   - 循环结束时 `i = 4`, `j = 3`。
   - `i` 指向 `nums.size()`（即 4），因为不存在大于等于 8 的元素。

---

# 2.快慢指针

## 2.1 查找链表中点

示例：

```cpp
ListNode *find_middle(ListNode* head){
    ListNode *slow = head, *fast = head;
	
    while(fast && fast->next){
        fast = fast->next->next;
        slow = slow-next
    }

    return slow;
}
```

如这段代码所示，设置快慢指针，让 `fast` 节点走的步数是 `slow` 节点走的步数的两倍。

循环结束后，`slow` 的指向：
- 节点数为奇数：`slow` 正好指向链表中点。
- 节点数为偶数：`slow` 指向后半部分的第一个节点。

这里的 `fast && fast->next` 这是标准的快慢指针写法，适用于链表长度为 **偶数或奇数** 的情况（比如：若 `fast` 能到链表最后一个节点，那么执行`fast->next->next` 就会报错，因为 `fast->next` 此时就是 `nullptr`）。

> 快慢指针除了应用与找链表的中间节点，还可以求解”获取倒数第 `k` 个节点这种问题“，思考一下怎么通过快慢指针求解。

## 2.2 删除数组中元素

下面介绍一种经典的**双指针技巧**，是一种高效的原址删除算法。

```cpp
void remove_target(std::vector<int> &nums, int target){
	int i = 0;
	
	for(int j = 0; j < nums.size(); ++j){
		if(nums[j] != target){
			nums[i] = nums[j];
			++i;
		}
	}
	
	nums.resize(i);
}
```

**双指针角色：**

- **`i` 指针（慢指针）**：指向下一个应该存放**保留元素**的位置，循环结束后，**`i` 的值 = 有效元素个数 = 新数组长度**。
    
- **`j` 指针（快指针）**：遍历整个数组，检查每个元素。

当 `nums[j] == target` 时（第一次），`i` 指针就会指向 `target` 元素的位置，下次循环的时候会用下一个值 `nums[j]` 覆盖掉 `nums[i]`，再次循环的时候，会把数组中的元素往前移（因为 `i` 落后与 `j`）。

可视化实例，删除数组中的元素 `3`：

```
步骤   i   j  nums[j]  操作          数组状态
初始   0   0    3      跳过        [3,5,3,2,9,10,3,4]
1      0   1    5      复制→i=0    [5,5,3,2,9,10,3,4] → i=1
2      1   2    3      跳过        [5,5,3,2,9,10,3,4]
3      1   3    2      复制→i=1    [5,2,3,2,9,10,3,4] → i=2  
4      2   4    9      复制→i=2    [5,2,9,2,9,10,3,4] → i=3
5      3   5    10     复制→i=3    [5,2,9,10,9,10,3,4] → i=4
6      4   6    3      跳过        [5,2,9,10,9,10,3,4]
7      4   7    4      复制→i=4    [5,2,9,10,4,10,3,4] → i=5

最终：i = 5（有效元素个数）
```

---

# 2.Boyer-Moore 投票算法

这是一个很经典的算法，用于查找数组中出现次数超过一半的“主元素”（majority element）。

## 2.1 算法思路

1. 核心思想：**抵消法**
	- 主元素出现次数 > `n/2`。
	- 所以我们可以假设：**每个非主元素都会“抵消”一个主元素**。
	- 但如果主元素真的存在，它最终不会被完全抵消。

> 这个算法的关键在于：**只有当主元素存在时，这个“幸存者”才是主元素。否则幸存者可能是任意值。**所以必须进行第二遍验证！

2. 时间 & 空间复杂度

| 项目 | 复杂度 | 说明 |
|------|--------|------|
| 时间复杂度 | O(n) | 两遍遍历 |
| 空间复杂度 | O(1) | 只用常数额外空间 |

## 2.2 代码

```cpp
int boyerMoore(const std::vector<int> &nums) {
    if (nums.empty()) {
        return -1;
    }

    int count = 0;
    int candidate_num = 0;

    // 投票阶段
    for (int val : nums) {
        if (count == 0) {
            candidate_num = val;
        }
        count += (val == candidate_num) ? 1 : -1;
    }

    // 验证阶段
    count = 0;
    for (int val : nums) {
        if (val == candidate_num) {
            count++;
        }
    }

    return (count > nums.size() / 2) ? candidate_num : -1;
}
```

1. **第一遍扫描（投票阶段）**  
   - 维护一个候选值 `candidate_num` 和计数器 `count`。
   - 遇到相同值就 `count++`，不同就 `count--`。
   - 如果 `count == 0`，就换当前元素为新的候选。
   - 这个过程的原理是：**主元素的数量超过一半，所以它能“抵消”所有其他元素后仍然存活。**

2. **第二遍扫描（验证阶段）**  
   - 重新统计 `candidate_num` 的实际出现次数。
   - 判断是否真的超过 `n/2`，防止不存在主元素时误判。

3. **返回结果**  
   - 如果确实超过一半，返回该数；否则返回 `-1`。

---

# 3.三数组最小曼哈顿距离

“三数组最小曼哈顿距离”也被称为“三元组最短距离”。

## 3.1 问题定义和解析

给定三个**递增排序的数组** `A`, `B`, `C`，从每个数组中各选一个数构成三元组 `(a, b, c)`，定义其**距离**为：

$$
\text{dist} = |a - b| + |b - c| + |c - a|
$$

目标：**找出所有可能三元组中距离最小的一个**。

注意我们定义的距离：

$$
|a - b| + |b - c| + |c - a|
$$

这个表达式其实可以**化简**，对于任意三个实数 $a, b, c$，有恒等式：

$$
|a - b| + |b - c| + |c - a| = 2 \times (\max(a,b,c) - \min(a,b,c))
$$

✅ **证明思路**：

假设 $a \leq b \leq c$，则：
- $|a-b| = b - a$
- $|b-c| = c - b$
- $|c-a| = c - a$
- 总和：$(b - a) + (c - b) + (c - a) = 2c - 2a = 2(c - a)$

所以：
$$
\text{dist} = 2 \times (\text{max} - \text{min})
$$

## 3.2 思路：三指针 + 贪心移动

> **要最小化三元组的距离，应该让三个数尽可能“靠近”**。

我们可以使用 **三指针法（Three Pointers）**，从每个数组的开头开始，每次移动指向**当前最小值**的那个指针。

为什么呢？

- 因为最大距离通常由最大值和最小值决定
- 当前最小值如果不增大，其他值再大也只会让距离更大
- 所以我们应该尝试**增大最小值**，使三数更接近

## 3.3 代码

```cpp
int get_min_dist(const std::vector<int> &A, const std::vector<int> &B, const std::vector<int> &C){
	int min_dist = INT_MAX;
	
	// 定义分别指向 A B C 中元素的指针
	int i = 0, j = 0, k = 0;
	while(i < A.size() && j < B.size() && k < C.size()){
		int a = A[i], b = B[j], C = C[k];
		
		// 计算当前三元组的距离
		int min_val = std::min({a, b, c});
		int max_val = std::max({a, b, c});
		
		int dist = 2 * (max_val - min_val);
		min_dist = std::min(dist, min_dist);
		
		// 移动指向最小值的指针
		if(a == min_val){
			++i;
		}
		else if(b == min_val){
			++j;
		}
		else{
			++k;
		}
	}

	return min_dist;
}
```

- 每次移动最小值的指针，是在尝试“拉近”三个数
- 因为数组有序，不移动最小值只会让差距更大
- 虽然不能证明**一定不会错过最优解**，但在这种对称距离函数下，该贪心策略是正确的（可通过反证法证明）

> 注意：这个贪心策略依赖于距离函数的性质。如果是其他距离（如欧氏距离），可能不适用。

---



