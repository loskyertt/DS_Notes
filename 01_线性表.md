---
title: 线性表
date: 2025-03-06 16:23:47
tags:
    - "cpp"
excerpt: "(*/ω＼*)"
categories: "数据结构"
---

# 1.重要知识点

1. 数据结构是相互之间存在 **一种或多种特定关系** 的数据元素集合。

2. 算法的五个特性：
   - 有穷性：算法必须在执行有穷步之后终止，即一个算法的操作步骤是有限的。
   - 确定性：算法中的每一条指令都必须都有确切的含义，并且对于特定的输入有特定的输出。
   - 有输入：算法有零个或多个输入，它们是算法开始前赋予参与运算的各个变量的初始值。
   - 有输出：算法有一个或多个输出，输出的值应该是算法计算得出的结果。
   - 可行性：算法是能够执行的，即算法中定义的操作都可以通过已经实现的基本运算执行有限次来实现。

3. 数据结构包括三个方面的内容：**逻辑结构**、**存储结构**、**数据的运算**。（容易把**数据的运算**忽略掉！！）

4. 在单链表中设置头节点的作用是 **便于插入和删除操作** 。

5. 顺序表：
   - 插入：平均移动 $n/2$ 个元素，即 $\frac{n(n+1)/2}{n+1}$ 。
   - 删除：平均移动 $(n-1)/2$ 个元素，即 $\frac{n(n-1)/2}{n}$ 。

推导：
插入有 $n+1$ 个位置，如：
```bash
  A   B   C   D     // 一共有 5 个位置
^   ^   ^   ^   ^
```
删除有 $n$ 个位置，如：
```bash
A B C D     // 一共有 4 个位置
^ ^ ^ ^
```

6. **线性表** 中元素的位序是从**1**开始的，而**数组**中元素的下标是从**0**开始的。

7. **链表中头节点和头指针的关系：** 不管带不带头节点，头指针始终指向链表的第一个节点。

示例（这里的`head`表示头指针）：
**不带头节点的单链表：**

```bash
head
 |
[1] → [2] → [3] → nullptr
```

```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* head = new ListNode(1); // 头指针指向第一个数据节点
head->next = new ListNode(2);
head->next->next = new ListNode(3);
```

**带头节点的单链表：**

```bash
head
 |
[X] → [1] → [2] → [3] → nullptr
```

（`X`代表头节点，不存储有效数据）

```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* head = new ListNode(0); // 头节点（不存储有效数据）
head->next = new ListNode(1);
head->next->next = new ListNode(2);
head->next->next->next = new ListNode(3);
```

8. 对于一个**带头节点**的循环单链表 `L`，判断该表为空表的条件是 `L->next = L`：

---

# 2.常用算法

## 2.1 快慢指针

示例：

```cpp
ListNode *find_middle(ListNode* head){
    ListNode *slow = head, *fast = head;

    while(fast && fast->next){
        fast = fast->next->next;
        slow = slow-next
    }

    return slow;
}
```

如这段代码所示，设置快慢指针，让 `fast` 节点走的步数是 `slow` 节点走的步数的两倍，这种方式可以快速定位到链表的中点。这里的 `fast && fast->next` 这是标准的快慢指针写法，适用于链表长度为 **偶数或奇数** 的情况， **不能写成 `while (fast)` 或 `while (fast->next)`** 。

快慢指针除了应用与找链表的中间节点，还可以求解”获取倒数第 `k` 个节点这种问题“，思考一下怎么通过快慢指针求解。

## 2.2 反转链表

下面代码可以实现把一个链表反转：

```cpp
ListNode *reverse_LinkedList(ListNode* head){
    ListNode *prev = nullptr;   // 前一个节点
    ListNode *curr = head;  // 当前节点

    while(head){
        ListNode* nextNode = curr->next;    // 保存当前节点的下一个节点
        curr->next = prev;  // 当前节点指针指向前一个节点
        prev = curr;    // 前一个节点移到当前节点
        curr = nextNode;    // 当前节点移到“当前节点的下一个节点”
    }

    return prev;
}
```

## 2.3 枚举法

比如求两个顺序表的交集，使用枚举法暴力求解（这种思路也能求两个链表的交集）：

```cpp
void get_intersection_enumerate(vector<int> &A, vector<int> &B, int lenA, int lenB){
    vector<int> C;

    for(int i = 0; i < lenA; i++){
        for(int j = 0; j < lenB; j++){
            if(A[i] == B[j]){
                C.push_back(A[i]);
            }
        }
    }

    cout << "枚举法查找结果：";
    for(int val : C){
        cout << val << " ";
    }
    cout << endl;
}
```

很显然，枚举法的时间复杂度达到 $O(n^2)$ ，如果想降低时间复杂度，可以使用哈希集合：

```cpp
void get_intersection_hash(vector<int> &A, vector<int> &B, int lenA, int lenB){
    // 会自动对 A 中的元素进行去重
	unordered_set<int> setA(A.begin(), A.end());
    vector<int> C;

    for(int i = 0; i < lenB; i++){
        // 对于 find() 方法，如果没有找到指定的元素（B[i]），它会返回 end() 迭代器。如果不相等的话，说明 B[i] 在集合 setA 中
        if(setA.find(B[i]) != setA.end()){
            C.push_back(B[i]);
            setA.erase(B[i]);   // 防止重复添加
        }
    }

    cout << "通过哈希表查找结果：";
    for (int val : C) {
        cout << val << " ";
    }
    cout << endl;
}
```

---

## 2.4 哈希集合去重

去除链表中包含重复值的节点（包括绝对值）。

> 注：链表带有头节点。

```cpp
void remove_duplicates(Node *node) {
  std::unordered_set<int> nums;
  
  Node *prev = nullptr;   // 记录前一个节点

  while (node) {
    // 如果当前节点值不在 nums 中
    if (nums.find(std::abs(node->val)) == nums.end()) {
      // 把该节点值放入集合中
      nums.insert(std::abs(node->val));
      prev = node;
      node = node->next;
    }
    // 在 nums 中
    else {
      Node *nxt = node->next;
      delete node;
      node = nxt;
      prev->next = node;
    }
  }
}
```